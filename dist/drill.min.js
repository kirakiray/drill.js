/*!
* drill.js v4.0.0
* https://github.com/kirakiray/drill.js
* 
* (c) 2018-2021 YAO
* Released under the MIT License.
*/(e=>{"use strict";const t=()=>Math.random().toString(32).substr(2);var s=Object.prototype.toString;const r=e=>(e=>s.call(e).toLowerCase().replace(/(\[object )|(])/g,""))(e).search("function")>-1;const{defineProperties:a}=Object,n=(()=>{const e=e=>Promise.resolve().then(()=>e());return"object"==typeof process&&process.nextTick&&(e=process.nextTick),e})(),o=new Map,c=(t,s)=>{o.set(t,s),a(e,{[t]:{value:e=>{let r=document.currentScript.src,a=u(r);a||(a=new f(r),p(r,a)),a.status=1,a.ptype=t,s({respone:e,record:a,relativeLoad(...e){let t=new k(...e);return t.__relative__=r,t}})}}})};c("define",async({respone:e,record:t,relativeLoad:s})=>{let a;if(r(e)){const r={};let n=await e({load:s,FILE:t.src,exports:r});void 0!==n||(e=>!(0 in Object.keys(e)))(r)||(n=r),a=(e=>n)}else a=(t=>e);t.done(a)}),c("task",async({respone:e,record:t,relativeLoad:s})=>{if(!r(e))throw"task must be a function";t.done(async r=>await e({data:r.data,load:s,FILE:t.src}))});const i=new Map,l=(e,t)=>{i.set(e,s=>{const r=u(s);return r.type=e,t({src:s,record:r})})};l("js",({src:e,record:t})=>new Promise((s,r)=>{let a=document.createElement("script");a.type="text/javascript",a.async=!0,a.src=e,t.sourceElement=a,a.addEventListener("load",async()=>{t.loadedTime=Date.now(),0==t.status&&(t.ptype="script",t.done(e=>{})),s()}),a.addEventListener("error",e=>{r({desc:"load script error",event:e})}),document.head.appendChild(a)})),l("mjs",async({src:e,record:t})=>{let s=await import(e);t.done(()=>s)}),l("wasm",async({src:e,record:t})=>{let s=await fetch(e).then(e=>e.arrayBuffer()),r=await WebAssembly.compile(s);const a=new WebAssembly.Instance(r);t.done(()=>a.exports)}),l("json",async({src:e,record:t})=>{let s=await fetch(e);s=await s.json(),t.done(()=>s)}),l("css",async({src:e,record:t})=>{let s=document.createElement("link");s.rel="stylesheet",s.type="text/css",s.href=e,t.sourceElement=s;let r=!1;t.done(async e=>{if(e.params.includes("-unpull"))return s;r||(document.head.appendChild(s),r=!0),s.sheet||await new Promise(e=>{s.addEventListener("load",t=>{e()})})})}),["html"].forEach(e=>{l(e,async({src:e,record:t})=>{let s=await fetch(e).then(e=>e.text());t.done(()=>s)})});const d=async({src:e,record:t})=>{let s=await fetch(e);if(!s.ok)throw{desc:"fetch "+s.statusText,response:s};t.done(()=>s)},h=new Map,p=(e,t)=>{let s=new URL(e);h.set(s.origin+s.pathname,t)},u=e=>{let t=new URL(e);return h.get(t.origin+t.pathname)};class f{constructor(e){this.src=e,this.status=0,this.bid="b_"+t(),this.data=new Promise((e,t)=>{this.__resolve=e,this.__reject=t}),this.startTime=Date.now()}done(e){this.status=2,this.__resolve(e),delete this.__resolve,delete this.__reject,this.doneTime=Date.now()}fail(e){this.status=-1,this.__reject(data),delete this.__resolve,delete this.__reject,this.doneTime=Date.now()}}const w={};const m=new Map;class y{constructor(e,t){let[s,...r]=e.split(" ");this.url=s,this.params=r,this.bag=t}get src(){let{url:e}=this;if(/^@.+/.test(e))for(let[t,s]of m)if(t.test(e)){e=e.replace(t,s);break}if(this.params.includes("-p")){e+=`/${e.replace(/.+\/(.+)/,"$1")}.js`}return new URL(e,this.relative).href}get ftype(){let e=new URL(this.src).pathname.replace(/.+\.(.+)/,"$1");return this.params.some(t=>{if(/^:(.+)/.test(t))return e=t.replace(/^:(.+)/,"$1"),!0}),e}get data(){return this.bag[b]}get relative(){return this.bag.__relative__||location.href}}function v(e){e.args.forEach(t=>e.result.push(void 0));let t=0,s=!1,{result:r}=e;const a=e[j];e.args.forEach((n,o)=>{let c=new y(n,e),l=n=>{r[o]=n,t++,a&&a({index:o,pkg:c,data:n}),1===e.args.length?e[g](n):t!==e.args.length||s||e[g](r),l=null};c.params.includes("-link")?l(c.src):c.params.includes("-pkg")?l(c):async function(e){let t=u(e.src);if(t){if(-1==t.status)throw{expr:e.url,src:t.src};const s=await t.data;return await s(e)}t=new f(e.src),p(e.src,t);let s=i.get(e.ftype);try{s?await s(t.src):(w[e.ftype]||(console.warn({desc:"did not find this loader",type:e.ftype}),w[e.ftype]=1),await d({src:t.src,record:t}))}catch(e){t.fail(e)}const r=await t.data;return await r(e)}(c).then(l).catch(t=>{s=!0,t&&console.error({expr:n,src:c.src,...t}),r[o]=t,e[_]({expr:n,src:c.src,error:t}),l=null})})}const g=Symbol("resolve"),_=Symbol("reject"),b=Symbol("postData"),j=Symbol("pendFunc");class k extends Promise{constructor(...e){if(r(e[0]))return super(...e),this;let s,o;super((e,t)=>{s=e,o=t}),this.id="d_"+t(),a(this,{[g]:{value:s},[_]:{value:o},args:{value:e},result:{value:[]},__relative__:{writable:!0,value:""}}),n(()=>v(this))}pend(e){if(this[j])throw{desc:"pend has been used",target:this};return a(this,{[j]:{value:e}}),this}post(e){if(this[b])throw{desc:"post has been used",target:this};return a(this,{[b]:{value:e}}),this}}const x=e.load=((...e)=>new k(...e));a(e,{drill:{value:{load:x,config:e=>{let{paths:t}=e;t&&Object.keys(t).forEach(e=>{let s=t[e];if(!/^@.+\/$/.test(e))throw{desc:"incorrect definition of paths",key:e};if(!/.+\/$/.test(e))throw{desc:"incorrect definition of paths",key:e,path:s};m.set(new RegExp("^"+e),s)})},async has(e){let t=await x(`${e} -link`);return!!u(t)},async remove(e){let t=await x(`${e} -link`),s=u(t).sourceElement;s&&s.parentNode.removeChild(s),h.delete(t)},ext(e){e({bag:h,addLoader:l,addProcess:c})},bag:h,version:"4.0.0",v:4e6}}})})("undefined"!=typeof globalThis?globalThis:window);
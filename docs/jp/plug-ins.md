# プラグインの開発の詳細

より多くのファイルタイプをサポートするために、drill.jsライブラリの機能を拡張する際には、以下の手順に従うことができます： 
1. ソースコードの確認 
   - まず、drill.jsの[ソースコード](https://github1s.com/kirakiray/drill.js/blob/main/src/use.mjs) を確認して、既存のファイルタイプの読み込みと処理をどのようにサポートしているかを理解します。 
   - 公式の [useの例示コード](https://github1s.com/kirakiray/drill.js/blob/main/examples/lm-use/index.html) 
   - 公式の `less` プラグインのサポートの[ソースコード](https://github1s.com/kirakiray/drill.js/blob/main/libs/less/src/init.js) 
2. `lm.use` メソッドの使用 
   - drill.jsは、ファイルタイプのサポートを拡張するために `lm.use` メソッドを提供しています。 
   - `lm.use` メソッドは、`fileType` と `middleware` 関数の2つのパラメータを受け取ります。 
   - `fileType` は拡張するファイルタイプであり、ファイルの拡張子にマッチするための文字列または文字列の配列です。 
   - `middleware` 関数は、特定のファイルタイプの読み込みと処理のロジックを処理するためのミドルウェア関数です。 
3. ミドルウェア関数のパラメータ 
   - ミドルウェア関数は、`ctx` と `next` の2つのパラメータを受け取ります。 
   - `ctx` は現在読み込まれているファイルに関する関連情報を含むコンテキストオブジェクトです。 
   - `ctx.url`：ファイルのURLアドレス。 
   - `ctx.result`：ミドルウェア処理の結果を格納するためのものです。 
   - `ctx.element`：宣言的なファイルの読み込みを使用している場合、読み込まれたファイルのタグです。 
   - `next` は次のミドルウェアを呼び出すための関数です。 
4. ミドルウェア関数のロジック
   - ミドルウェア関数は、必要に応じてカスタムの処理ロジックを持つことができます。例えば、ファイルの読み込みやコンテンツの処理などです。 
   - `ctx.result` を変更することで、後続のミドルウェアやコードで使用するために処理後の結果を保存することができます。 
5. `next()` 関数の実行 
   - ミドルウェア関数内で、適切な位置で `next()` 関数を呼び出すことが重要です。これにより、次のミドルウェアが実行されます。 
   - `next()` を呼び出さない場合、後続のミドルウェアは実行されません。

以下は、`.txt` ファイルの読み込みと処理を拡張するために `lm.use` メソッドを使用する例です：

```javascript
lm.use("txt", async (ctx, next) => {
  const { url } = ctx;

  // ファイルの読み込みロジックをここで実行
  const response = await fetch(url);
  const text = await response.text();

  // 処理後の結果を ctx.result に保存
  ctx.result = text;

  // next() 関数を呼び出して、次のミドルウェアを実行
  next();
});
```

上記の例では、ミドルウェア関数が `.txt` ファイルのコンテンツを読み込み、結果を `ctx.result` に保存しています。`next()` 関数を呼び出すことにより、次のミドルウェアがファイルを処理できるようになります。

これらの手順に従うことで、`lm.use` メソッドを使用して drill.js の機能を拡張し、他のさまざまなファイルの読み込みと処理をサポートすることができます。必要に応じてカスタムのミドルウェア関数を作成し、特定のファイルタイプのロジックを処理し、`ctx.result` をミドルウェア関数内で結果の保存に使用します。